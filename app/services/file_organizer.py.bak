"""
@description 文件整理服务核心逻辑
@responsibility 处理文件整理、重命名、移动及清理操作
"""

import asyncio
from typing import Optional

from loguru import logger

from app.core.database import get_session
from app.models.organize_record import OrganizeRecord
from app.services.file_filter import filter_files
from app.services.fanhao_parser import (
    remove_keywords,
    normalize_filename,
    extract_fanhao,
    normalize_cd_suffix,
    generate_target_path,
    extract_producer,
)


class FileOrganizer:
    """文件整理服务"""

    def __init__(self, p115_client):
        self._client = p115_client
        self._lock = asyncio.Lock()

    async def organize_task(
        self,
        task_info: dict,
        library_config: dict,
        media_config: dict,
        xx_config: Optional[dict] = None,
    ) -> dict:
        """
        整理单个任务的文件

        Args:
            task_info: 任务信息，包含 task_id, info_hash, path_id, name
            library_config: 媒体库配置
            media_config: 媒体配置（视频格式、最小大小）
            xx_config: 成人片库配置（可选）

        Returns:
            整理结果统计 {success_count, failed_count, skipped_count, errors}
        """
        # 添加调试日志
        import traceback

        logger.debug(f"[organize_task] task_info keys: {list(task_info.keys())}")
        logger.debug(
            f"[organize_task] library_config keys: {list(library_config.keys())}"
        )

        try:
            async with self._lock:
                logger.debug(f"[organize_task-1] 获取 task_id 和 path_id")
                task_id = task_info["task_id"]
                path_id = task_info["path_id"]

                logger.debug(f"[organize_task-2] 调用 list_directory")
                dir_response = await self._client.list_directory(path_id)
                if not dir_response.get("state"):
                    logger.error(f"任务 {task_id} 获取目录列表失败")
                    return result

                files = dir_response.get("data", [])
                if not files:
                    logger.warning(f"任务 {task_id} 无文件可整理")
                    return result

                logger.debug(f"[organize_task-3] 构建 filter_config")
                filter_config = {
                    "video_formats": media_config.get("video_formats", []),
                    "min_transfer_size": library_config.get(
                        "min_transfer_size", media_config.get("min_transfer_size", 0)
                    ),
                }
                video_files = filter_files(files, filter_config)

                if not video_files:
                    logger.warning(f"任务 {task_id} 无符合条件的视频文件")
                    return result

                logger.debug(f"[organize_task-4] 获取 library_type")
                library_type = library_config.get("type", "system")

                if library_type == "system":
                    logger.debug(f"[organize_task-5] 调用 organize_files_system")
                    organize_result = await self.organize_files_system(
                        video_files,
                        library_config["target_path"],
                        task_id,
                        library_config,
                    )
                elif library_type.startswith("xx-"):
                    producer = extract_producer(library_type)
                    logger.debug(f"[organize_task-6] 调用 organize_files_xx")
                    organize_result = await self.organize_files_xx(
                        video_files,
                        library_config["target_path"],
                        producer,
                        xx_config or {},
                        task_id,
                        library_config,
                    )
                else:
                    logger.warning(f"未知的媒体库类型: {library_type}")
                    return result

                logger.debug(f"[organize_task-7] 返回结果")
                result["success_count"] = organize_result["success_count"]
                result["failed_count"] = organize_result["failed_count"]
                result["skipped_count"] = organize_result["skipped_count"]
                result["errors"] = organize_result["errors"]

                return result
        except KeyError as e:
            logger.error(f"[organize_task-KeyError] KeyError: {e}")
            logger.error(f"[organize_task-KeyError] 完整的 task_info: {task_info}")
            logger.error(
                f"[organize_task-KeyError] 完整的 library_config: {library_config}"
            )
            logger.error(
                f"[organize_task-KeyError] 堆栈跟踪:\n{traceback.format_exc()}"
            )
            raise
        except Exception as e:
            logger.error(f"[organize_task-Error] {e}")
            logger.error(f"[organize_task-Error] 堆栈跟踪:\n{traceback.format_exc()}")
            raise

            files = dir_response.get("data", [])
            if not files:
                logger.warning(f"任务 {task_id} 无文件可整理")
                return result

            filter_config = {
                "video_formats": media_config.get("video_formats", []),
                "min_transfer_size": library_config.get(
                    "min_transfer_size", media_config.get("min_transfer_size", 0)
                ),
            }
            video_files = filter_files(files, filter_config)

            if not video_files:
                logger.warning(f"任务 {task_id} 无符合条件的视频文件")
                return result

            library_type = library_config.get("type", "system")

            if library_type == "system":
                organize_result = await self.organize_files_system(
                    video_files, library_config["target_path"], task_id, library_config
                )
            elif library_type.startswith("xx-"):
                producer = extract_producer(library_type)
                organize_result = await self.organize_files_xx(
                    video_files,
                    library_config["target_path"],
                    producer,
                    xx_config or {},
                    task_id,
                    library_config,
                )
            else:
                logger.warning(f"未知的媒体库类型: {library_type}")
                return result

            result["success_count"] = organize_result["success_count"]
            result["failed_count"] = organize_result["failed_count"]
            result["skipped_count"] = organize_result["skipped_count"]
            result["errors"] = organize_result["errors"]

            return result

    async def organize_files_system(
        self,
        files: list[dict],
        target_dir: str,
        task_id: str,
        library_config: dict,
    ) -> dict:
        """
        system 类型整理 - 直接移动文件到目标目录

        Args:
            files: 待整理文件列表
            target_dir: 目标目录路径
            task_id: 任务 ID
            library_config: 媒体库配置

        Returns:
            整理结果统计
        """
        result = {
            "success_count": 0,
            "failed_count": 0,
            "skipped_count": 0,
            "errors": [],
        }

        target_id = await self._client.get_path_id(target_dir)
        if not target_id:
            logger.error(f"无法获取目标目录 ID: {target_dir}")
            result["failed_count"] = len(files)
            return result

        for file in files:
            file_id = file.get("cid", 0)
            file_name = file.get("n", "")
            file_size = file.get("sz", 0) or file.get("size", 0)

            try:
                move_response = await self._client.move_file(file_id, target_id)

                if move_response.get("state"):
                    result["success_count"] += 1
                    logger.info(f"文件 {file_name} 移动成功")

                    await self.save_organize_record(
                        {
                            "task_id": task_id,
                            "source_path": f"/{file_id}",
                            "target_path": f"{target_dir}/{file_name}",
                            "file_name": file_name,
                            "file_size": file_size,
                            "library_name": library_config.get("name", ""),
                            "status": "success",
                            "error_message": None,
                        }
                    )
                else:
                    result["skipped_count"] += 1
                    logger.warning(
                        f"文件 {file_name} 跳过: {move_response.get('error', '已存在')}"
                    )

                    await self.save_organize_record(
                        {
                            "task_id": task_id,
                            "source_path": f"/{file_id}",
                            "target_path": f"{target_dir}/{file_name}",
                            "file_name": file_name,
                            "file_size": file_size,
                            "library_name": library_config.get("name", ""),
                            "status": "skipped",
                            "error_message": move_response.get("error", "文件已存在"),
                        }
                    )

            except Exception as e:
                result["failed_count"] += 1
                result["errors"].append(str(e))
                logger.error(f"文件 {file_name} 整理失败: {e}")

                await self.save_organize_record(
                    {
                        "task_id": task_id,
                        "source_path": f"/{file_id}",
                        "target_path": f"{target_dir}/{file_name}",
                        "file_name": file_name,
                        "file_size": file_size,
                        "library_name": library_config.get("name", ""),
                        "status": "failed",
                        "error_message": str(e),
                    }
                )

        return result

    async def organize_files_xx(
        self,
        files: list[dict],
        target_dir: str,
        producer: str,
        xx_config: dict,
        task_id: str,
        library_config: dict,
    ) -> dict:
        """
        xx-片商类型整理 - 处理番号提取、重命名和移动

        Args:
            files: 待整理文件列表
            target_dir: 目标目录路径
            producer: 片商名称
            xx_config: 成人片库配置（包含 remove_keywords）
            task_id: 任务 ID
            library_config: 媒体库配置

        Returns:
            整理结果统计
        """
        result = {
            "success_count": 0,
            "failed_count": 0,
            "skipped_count": 0,
            "errors": [],
        }

        file_count = len(files)
        keywords = xx_config.get("remove_keywords", [])

        for file in files:
            file_id = file.get("cid", 0)
            original_name = file.get("n", "")
            file_size = file.get("sz", 0) or file.get("size", 0)

            try:
                processed_name = remove_keywords(original_name, keywords)
                processed_name = normalize_filename(processed_name)

                fanhao = extract_fanhao(processed_name)
                if not fanhao:
                    result["skipped_count"] += 1
                    logger.warning(f"无法从 {original_name} 提取番号，跳过")
                    continue

                processed_name = normalize_cd_suffix(processed_name, file_count)
                final_target_path = generate_target_path(
                    processed_name, target_dir, producer
                )
                target_dir_path = "/".join(final_target_path.rsplit("/", 1)[:-1])
                target_id = await self._client.get_path_id(target_dir_path)

                if not target_id:
                    result["failed_count"] += 1
                    result["errors"].append(f"无法创建目标目录: {target_dir_path}")
                    continue

                rename_response = await self._client.rename_file(
                    file_id, processed_name
                )
                if not rename_response.get("state"):
                    logger.warning(f"重命名失败，使用原文件名: {original_name}")

                move_response = await self._client.move_file(file_id, target_id)

                if move_response.get("state"):
                    result["success_count"] += 1
                    logger.info(f"文件 {original_name} -> {processed_name} 整理成功")

                    await self.save_organize_record(
                        {
                            "task_id": task_id,
                            "source_path": f"/{file_id}/{original_name}",
                            "target_path": final_target_path,
                            "file_name": processed_name,
                            "file_size": file_size,
                            "library_name": library_config.get("name", ""),
                            "status": "success",
                            "error_message": None,
                        }
                    )
                else:
                    result["skipped_count"] += 1
                    logger.warning(
                        f"文件 {processed_name} 跳过: {move_response.get('error', '已存在')}"
                    )

            except Exception as e:
                result["failed_count"] += 1
                result["errors"].append(str(e))
                logger.error(f"文件 {original_name} 整理失败: {e}")

        return result

    async def save_organize_record(self, record: dict) -> None:
        """
        保存整理记录到数据库

        Args:
            record: 整理记录字典
        """
        try:
            async with get_session() as session:
                organize_record = OrganizeRecord(
                    task_id=record["task_id"],
                    source_path=record["source_path"],
                    target_path=record["target_path"],
                    file_name=record["file_name"],
                    file_size=record["file_size"],
                    library_name=record["library_name"],
                    status=record["status"],
                    error_message=record.get("error_message"),
                )
                session.add(organize_record)
                await session.commit()
                logger.debug(f"整理记录已保存: {record['file_name']}")
        except Exception as e:
            logger.error(f"保存整理记录失败: {e}")

    async def cleanup_source(
        self, task_id: str, info_hash: str, source_files: list[dict]
    ) -> None:
        """
        清理源文件和离线任务

        Args:
            task_id: 任务 ID
            info_hash: 离线任务 hash
            source_files: 源文件列表
        """
        for file in source_files:
            file_id = file.get("cid", 0)
            file_name = file.get("n", "")
            try:
                await self._client.delete_file(file_id)
                logger.info(f"源文件 {file_name} 已删除")
            except Exception as e:
                logger.error(f"删除源文件 {file_name} 失败: {e}")

        try:
            await self._client.delete_offline_task(info_hash)
            logger.info(f"离线任务 {task_id} 已删除")
        except Exception as e:
            logger.error(f"删除离线任务 {task_id} 失败: {e}")
